glue.command(["multi-delete", "alignment", "-w", "name like 'BTV_OUTG_CODON_%'"]);

var segments = ["1", "2", "3", "4", "5", "6", "7", "8", "9", "10"];

function almtName(segment) {
	return "BTV_OUTG_CODON_"+segment;
}

_.each(segments, function(segNum) {
	var alName = almtName(segNum);
	glue.inMode("module/btvBlastFastaProteinAlignmentImporter", function() {
		glue.command(["import", alName, "-f", "alignments/btvOutgroupProtein/BTV_OUTG_ALIGNED_"+segNum+".faa"]);
	});
	
	fixStopCodons(alName);
	
	glue.inMode("module/fastaAlignmentExporter", function() {
		glue.command(["export", alName, "--allMembers", "--fileName", "alignments/btvOutgroupCodon/"+alName+".fna"]);
	});
	glue.inMode("alignment/"+alName, function() {
		glue.command(["export", "command-document", "--fileName", "alignments/btvOutgroupCodon/"+alName+".json"]);
	});

	
});


/**
 * Since the BTV_OUTG_ALIGNED_...faa files were generated by running MAFFT as a protein aligner, all the 
 * stop codons are absent. But, GLUE prefers to have these present in coding regions, so it is 
 * better to have these in the unconstrained alignment which will define these coding regions.
 *
 * This function adds the stop codons to the alignment. It's complicated by the fact that some alignment
 * member rows don't run all the way up to a stop codon. 
 */

function fixStopCodons(alName) {
	var memberObs;
	var maxRefEnd = { value: 0 };
	glue.inMode("alignment/"+alName, function() {
		memberObjs = glue.tableToObjects(glue.command(["list", "member"]));
		_.each(memberObjs, function(memberObj) {
			glue.inMode("member/"+memberObj["sequence.source.name"]+"/"+memberObj["sequence.sequenceID"], function() {
				var segmentObjs = glue.tableToObjects(glue.command(["list", "segment"]));
				var refEnd = _.max(segmentObjs, function(obj) {return obj.refEnd;}).refEnd;
				if(refEnd > maxRefEnd.value) {
					maxRefEnd.value = refEnd;
				}
				memberObj.maxMemberEnd = _.max(segmentObjs, function(obj) {return obj.memberEnd;}).memberEnd;

			});
		});
	});

	_.each(memberObjs, function(memberObj) {
		var sourceName = memberObj["sequence.source.name"];
		var sequenceID = memberObj["sequence.sequenceID"];
		
		var addStopCodon = false;
		glue.inMode("/sequence/"+sourceName+"/"+sequenceID, function() {
			var seqLength = glue.command(["show", "length"]).lengthResult.length;
			if(memberObj.maxMemberEnd <= seqLength - 3) {
				var next3Nts;
				next3Nts = glue.command(["show", "nucleotides", "-b", memberObj.maxMemberEnd+1, "-e", memberObj.maxMemberEnd+3])
					.nucleotidesResult.nucleotides.toUpperCase();
				if(next3Nts == "TAA" || next3Nts == "TAG" || next3Nts == "TGA") {
					addStopCodon = true;
				}
			}
		});
		if(addStopCodon) {
			glue.inMode("alignment/"+alName+"/member/"+sourceName+"/"+sequenceID, function() {
				glue.command(["add", "segment", 
				              maxRefEnd.value+1, maxRefEnd.value+3, 
				              memberObj.maxMemberEnd+1, memberObj.maxMemberEnd+3]);
			});
		}
	});

}